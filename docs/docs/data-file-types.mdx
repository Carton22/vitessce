---
id: data-file-types
title: File Types and File Formats
slug: /data-file-types
---
import ViewConfigTabs from '../src/pages/_ViewConfigTabs';
import FileDefTabs from '../src/pages/_FileDefTabs';

import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';

This page describes, for each file type, the configuration options and the file formatting requirements.

The file types and file formats listed here are natively (i.e., can be loaded directly without a conversion step) supported by Vitessce.
To use [other file formats](#other-file-formats) with Vitessce, there are two options: convert to format(s) supported by Vitessce, or develop a [plugin file type](/docs/dev-plugins/).


:::tip
If you encounter any issues, please check out our [data troubleshooting](/docs/data-troubleshooting/) page before opening an [issue](https://github.com/vitessce/vitessce/issues).
:::

:::info
The JSON file definition snippets found on this page would be specified as objects in the array [`datasets[].files[]`](/docs/view-config-json/#files) in the JSON view configuration.
:::


## `anndata.zarr`

Defines an AnnData object that has been written to a Zarr store. This is a [joint](/docs/data-types-file-types/#joint-file-types) file type.

<FileDefTabs
fileName="my_adata.zarr"
fileType="anndata.zarr"
fileConst="ANNDATA_ZARR"
options={`{
  "obsLocations": {
    // Accepts the same options as obsLocations.anndata.zarr
    "path": "obsm/X_centroids"
  },
  "obsSegmentations": {
    // Accepts the same options as obsSegmentations.anndata.zarr
    "path": "obsm/X_segmentations"
  },
  "obsEmbedding": [
    {
      // Accepts a superset of the options from obsEmbedding.anndata.zarr
      // Should point to an array of (d1, d2) coordinate pairs, one coordinate pair per obs/cell.
      "path": "obsm/X_umap",
      "dims": [0, 1],
      // An embeddingType must be specified to distinguish between multiple embedding arrays.
      "embeddingType": "UMAP"
    },
    {
      "path": "obsm/X_pca",
      "dims": [4, 5],
      "embeddingType": "PCA"
    }
  ],
  "obsLabels": [
    {
      // Accepts a superset of the options from obsLabels.anndata.zarr
      "path": "obs/alt_cell_id",
      // An obsLabelsType must be specified to distinguish between multiple label columns.
      "obsLabelsType": "Alternate cell ID"
    }
  ],
  "obsSets": [
    // Accepts the same options as obsSets.anndata.zarr
    {
      "name": "Cell Type Annotations",
      "path": ["obs/cell_type_coarse", "obs/cell_type_fine"]
    }
  ],
  "obsFeatureMatrix": {
    // Accepts the same options as obsFeatureMatrix.anndata.zarr
    // Should point to the observation-x-feature matrix
    "path": "X"
  }
}`}
coordinationValues={`{
  "obsType": "cell",
  "featureType": "gene",
  "featureValueType": "expression"
}`}
/>

## `obsEmbedding.anndata.zarr`

<FileDefTabs
fileName="my_adata.zarr"
fileType="obsEmbedding.anndata.zarr"
fileConst="OBS_EMBEDDING_ANNDATA_ZARR"
options={`{
  // Should point to an array of (d1, d2) coordinate pairs, one coordinate pair per obs/cell.
  "path": "obsm/X_umap",
  "dims": [0, 1]
}`}
coordinationValues={`{
  "obsType": "cell",
  "embeddingType": "UMAP"
}`}
/>

## `obsFeatureMatrix.anndata.zarr`

<FileDefTabs
fileName="my_adata.zarr"
fileType="obsFeatureMatrix.anndata.zarr"
fileConst="OBS_FEATURE_MATRIX_ANNDATA_ZARR"
options={`{
  // Should point to the observation-x-feature matrix
  "path": "X"
}`}
coordinationValues={`{
  "obsType": "cell",
  "featureType": "gene",
  "featureValueType": "expression"
}`}
/>

By default, rendering an observation-x-feature matrix in a heatmap requires fetching the entire matrix over the network which can result in a long initial load time and a large network request.
There are two ways to alleviate this issue when using the `obsFeatureMatrix.anndata.zarr` file type:
- Load (and therefore transfer over the network) only a subset of the matrix initially (`"initialFeatureFilterPath"`)
- Store a smaller matrix in an `obsm` array, and load that smaller matrix (`"featureFilterPath"`)

<FileDefTabs
fileName="my_adata.zarr"
fileType="obsFeatureMatrix.anndata.zarr"
fileConst="OBS_FEATURE_MATRIX_ANNDATA_ZARR"
options={`{
  // Should point to the observation-x-feature matrix
  "path": "obsm/X_subset",
  // If the matrix specified in "path" is a subset of X,
  // then "featureFilterPath" must point to a boolean array
  // that indicates which features are contained in the subsetted matrix.
  "featureFilterPath": "var/in_X_subset",
  // If you would like to limit the amount of data loaded
  // initially (specifically in the heatmap),
  // then "initialFeatureFilterPath" should point to a boolean array
  // that indicates which features to load initially.
  "initialFeatureFilterPath": "var/highly_variable"
}`}
coordinationValues={`{
  "obsType": "cell",
  "featureType": "gene",
  "featureValueType": "expression"
}`}
/>

## `obsLabels.anndata.zarr`

<FileDefTabs
fileName="my_adata.zarr"
fileType="obsLabels.anndata.zarr"
fileConst="OBS_LABELS_ANNDATA_ZARR"
options={`{
  // Should point to a string column
  "path": "obs/alt_cell_ids"
}`}
coordinationValues={`{
  "obsType": "cell",
  "obsLabelsType": "Alternate cell ID"
}`}
/>

## `obsLocations.anndata.zarr`

<FileDefTabs
fileName="my_adata.zarr"
fileType="obsLocations.anndata.zarr"
fileConst="OBS_LOCATIONS_ANNDATA_ZARR"
options={`{
  // Should point to an array of (x, y) coordinate pairs, one coordinate pair per obs/cell.
  "path": "obs/alt_cell_ids"
}`}
coordinationValues={`{
  "obsType": "cell"
}`}
/>

## `obsSegmentations.anndata.zarr`

<FileDefTabs
fileName="my_adata.zarr"
fileType="obsSegmentations.anndata.zarr"
fileConst="OBS_SEGMENTATIONS_ANNDATA_ZARR"
options={`{
  // Should point to an array of polygon vertices, one polygon per obs/cell.
  "path": "obs/X_segmentations"
}`}
coordinationValues={`{
  "obsType": "cell"
}`}
/>

## `obsSets.anndata.zarr`

<FileDefTabs
fileName="my_adata.zarr"
fileType="obsSets.anndata.zarr"
fileConst="OBS_SETS_ANNDATA_ZARR"
options={`[
  {
    "name": "Leiden Clustering",
    "path": "obs/leiden"
  },
  {
    "name": "Cell Type Annotations",
    "path": ["obs/cell_type_coarse", "obs/cell_type_fine"]
  },
  {
    "name": "Predicted Cell Types",
    "path": "obs/predicted_cell_type",
    "scorePath": "obs/prediction_score"
  }
]`}
coordinationValues={`{
  "obsType": "cell"
}`}
/>

## `featureLabels.anndata.zarr`

## `obsEmbedding.csv`

## `obsFeatureMatrix.csv`

## `obsLabels.csv`

## `obsLocations.csv`

## `obsSegmentations.json`

## `obsSets.csv`

## `obsSets.json`

## `featureLabels.csv`

## `image.raster.json`

## `obsSegmentations.raster.json`

## `image.ome-zarr`

## `genomic-profiles.zarr`



#### `anndata-expression-matrix.zarr`

- View config file definition snippet:

  <ViewConfigTabs
json={`
{
  "url": "http://example.com/my_store.zarr",
  "type": "expression-matrix",
  "fileType": "anndata-expression-matrix.zarr",
  "options": {
    "matrix": "X"
  }
}
`}
js={`
const options = {
  "matrix": "X"
};
const dataset = vc
  .addDataset("My dataset")
  .addFile(
    "http://example.com/my_store.zarr",
    dt.EXPRESSION_MATRIX,
    ft.ANNDATA_EXPRESSION_MATRIX_ZARR,
    options
  );
`}
  />
  

  <ViewConfigTabs
json={`
{
  "url": "http://example.com/my_store.zarr",
  "type": "expression-matrix",
  "fileType": "anndata-expression-matrix.zarr",
  "options": {
    // Matrix provides the location of an
    // obs-by-var (cell-by-gene) matrix to load into memory.
    "matrix": "obsm/X",
    // Matrix genes filter is a boolean list which defines
    // the subset of genes contained in the matrix to be visualized in the heatmap.
    // All of the genes in \`var\` will display in the \`Genes\` view though.
    // Use \`geneFilter\` instead if you only want to show a subset of the genes there
    // (this must be defined if the matrix is a subset of AnnData.X).
    "matrixGeneFilter": "var/highly_variable",
    // The gene alias property supports specifying a column containing
    // alternative gene identifiers.
    "geneAlias": "var/hugo_symbol"
  }
}
`}
js={`
const options = {
  // Matrix provides the location of an
  // obs-by-var (cell-by-gene) matrix to load into memory.
  "matrix": "obsm/X",
  // Matrix genes filter is a boolean list which defines
  // the subset of genes contained in the matrix to be visualized in the heatmap.
  // All of the genes in \`var\` will display in the \`Genes\` view though.
  // Use \`geneFilter\` instead if you only want to show a subset of the genes there
  // (this must be defined if the matrix is a subset of AnnData.X).
  "matrixGeneFilter": "var/highly_variable",
  // The gene alias property supports specifying a column containing
  // alternative gene identifiers.
  "geneAlias": "var/hugo_symbol"
};
const dataset = vc
  .addDataset("My dataset")
  .addFile(
    "http://example.com/my_store.zarr",
    dt.EXPRESSION_MATRIX,
    ft.ANNDATA_EXPRESSION_MATRIX_ZARR,
    options
  );
`}
  />

### `cells.json`

- [JSON schema](https://github.com/vitessce/vitessce/blob/main/src/schemas/cells.schema.json)
- [JSON schema fixture](https://github.com/vitessce/vitessce/blob/main/src/schemas/fixtures/cells.good.json)
- [Example file](https://s3.amazonaws.com/vitessce-data/0.0.31/master_release/dries/dries.cells.json)
- View config file definition snippet:

  <ViewConfigTabs
json={`
{
  "url": "http://example.com/my_cells.json",
  "type": "cells",
  "fileType": "cells.json"
}
`}
js={`
const dataset = vc
  .addDataset("My dataset")
  .addFile(
    "http://example.com/my_cells.json",
    dt.CELLS,
    ft.CELLS_JSON
  );
`}
  />


### `cell-sets.json`

- [JSON schema](https://github.com/vitessce/vitessce/blob/main/src/schemas/cell-sets.schema.json)
- [JSON schema fixture](https://github.com/vitessce/vitessce/blob/main/src/schemas/fixtures/cell-sets.good.json)
- [Example file](https://s3.amazonaws.com/vitessce-data/0.0.31/master_release/dries/dries.cell-sets.json)
- View config file definition snippet:

  <ViewConfigTabs
json={`
{
  "url": "http://example.com/my_cell_sets.json",
  "type": "cell-sets",
  "fileType": "cell-sets.json"
}
`}
js={`
const dataset = vc
  .addDataset("My dataset")
  .addFile(
    "http://example.com/my_cell_sets.json",
    dt.CELL_SETS,
    ft.CELL_SETS_JSON
  );
`}
  />


### `molecules.json`

- [JSON schema](https://github.com/vitessce/vitessce/blob/main/src/schemas/molecules.schema.json)
- [JSON schema fixture](https://github.com/vitessce/vitessce/blob/main/src/schemas/fixtures/molecules.good.json)
- [Example file](https://s3.amazonaws.com/vitessce-data/0.0.31/master_release/linnarsson/linnarsson.molecules.json)
- View config file definition snippet:

  <ViewConfigTabs
json={`
{
  "url": "http://example.com/my_molecules.json",
  "type": "molecules",
  "fileType": "molecules.json"
}
`}
js={`
const dataset = vc
  .addDataset("My dataset")
  .addFile(
    "http://example.com/my_molecules.json",
    dt.MOLECULES,
    ft.MOLECULES_JSON
  );
`}
  />

### `genes.json`

:::tip
The `genes.json` format is not very efficient from a file size perspective.
For large expression matrices, we recommend using the more compact Zarr `expression-matrix.zarr` or `anndata-expression-matrix.zarr` formats.
:::

- [JSON schema](https://github.com/vitessce/vitessce/blob/main/src/schemas/genes.schema.json)
- [JSON schema fixture](https://github.com/vitessce/vitessce/blob/main/src/schemas/fixtures/genes.good.json)
- [Example file](https://s3.amazonaws.com/vitessce-data/0.0.31/master_release/linnarsson/linnarsson.genes.json)
- View config file definition snippet:

  <ViewConfigTabs
json={`
{
  "url": "http://example.com/my_matrix_a.json",
  "type": "expression-matrix",
  "fileType": "genes.json"
}
`}
js={`
const dataset = vc
  .addDataset("My dataset")
  .addFile(
    "http://example.com/my_matrix_a.json",
    dt.EXPRESSION_MATRIX,
    ft.GENES_JSON
  );
`}
  />

### `clusters.json`

:::note
The name `clusters.json` is misleading; this file type is not intended to store clustering results (see `cell-sets.json` for storing clustering results).
`clusters.json` is meant to store cell-by-gene expression matrices.
:::

:::tip
The `clusters.json` format is not very efficient from a file size perspective.
For large expression matrices, we recommend using the more compact Zarr `expression-matrix.zarr` or `anndata-expression-matrix.zarr` formats.
:::

- [JSON schema](https://github.com/vitessce/vitessce/blob/main/src/schemas/clusters.schema.json)
- [JSON schema fixture](https://github.com/vitessce/vitessce/blob/main/src/schemas/fixtures/clusters.good.json)
- [Example file](https://s3.amazonaws.com/vitessce-data/0.0.31/master_release/linnarsson/linnarsson.clusters.json)
- View config file definition snippet:

  <ViewConfigTabs
json={`
{
  "url": "http://example.com/my_matrix_b.json",
  "type": "expression-matrix",
  "fileType": "clusters.json"
}
`}
js={`
const dataset = vc
  .addDataset("My dataset")
  .addFile(
    "http://example.com/my_matrix_b.json",
    dt.EXPRESSION_MATRIX,
    ft.CLUSTERS_JSON
  );
`}
  />


### `expression-matrix.zarr`

- View config file definition snippet:

  <ViewConfigTabs
json={`
{
  "url": "http://example.com/my_matrix.zarr",
  "type": "expression-matrix",
  "fileType": "expression-matrix.zarr"
}
`}
js={`
const dataset = vc
  .addDataset("My dataset")
  .addFile(
    "http://example.com/my_matrix.zarr",
    dt.EXPRESSION_MATRIX,
    ft.EXPRESSION_MATRIX_ZARR
  );
`}
  />

### `raster.json`

- [JSON schema for options](https://github.com/vitessce/vitessce/blob/main/src/schemas/raster.schema.json)

  :::note

  When defining image data with the `raster.json` file type, the main `url` property is not used.
  Instead, image URLs may be specified in the `images` array in the `options` property.

  :::note


- View config file definition snippet with an OME-TIFF image and segmentation bitmask:

  <ViewConfigTabs
json={`
{
  "type": "raster",
  "fileType": "raster.json",
  "options": {
    "renderLayers": ["My OME-TIFF Image", "My OME-TIFF Mask"],
    "schemaVersion": "0.0.2",
    "images": [
      {
        "name": "My OME-TIFF Image",
        "url": "http://example.com/my_image.ome.tif",
        "type": "ome-tiff",
        "metadata": {
          "transform": {
            // An optional transformation matrix
            // in column-major order.
            "matrix": [
              0.81915098, -0.57357901, 0, 3264.76514684,
              0.57357502, 0.819152, 0, 556.50440621,
              0, 0, 1, 0,
              0, 0, 0, 1
            ]
          }
        }
      },
      {
        "name": "My OME-TIFF Mask",
        "url": "http://example.com/my_mask.ome.tif",
        "type": "ome-tiff",
        "metadata": {
          "isBitmask": true
        }
      }
    ]
  }
}
`}
js={`
const options = {
  "renderLayers": ["My OME-TIFF Image", "My OME-TIFF Mask"],
  "schemaVersion": "0.0.2",
  "images": [
    {
      "name": "My OME-TIFF Image",
      "url": "http://example.com/my_image.ome.tif",
      "type": "ome-tiff",
      "metadata": {
        "transform": {
          // An optional transformation matrix
          // in column-major order.
          "matrix": [
            0.81915098, -0.57357901, 0, 3264.76514684,
            0.57357502, 0.819152, 0, 556.50440621,
            0, 0, 1, 0,
            0, 0, 0, 1
          ]
        }
      }
    },
    {
      "name": "My OME-TIFF Mask",
      "url": "http://example.com/my_mask.ome.tif",
      "type": "ome-tiff",
      "metadata": {
        "isBitmask": true
      }
    }
  ]
};
const dataset = vc
  .addDataset("My dataset")
  .addFile(
    undefined,
    dt.RASTER,
    ft.RASTER_JSON,
    options
  );
`}
  />

- View config file definition snippet with a Zarr store:

  <ViewConfigTabs
json={`
{
  "type": "raster",
  "fileType": "raster.json",
  "options": {
    "schemaVersion": "0.0.2",
    "images": [
      {
        "name": "My Bioformats-Zarr Image",
        "url": "http://example.com/my_image.zarr",
        "type": "zarr",
        "metadata": {
          "dimensions": [
            {
              "field": "channel",
              "type": "nominal",
              "values": [
                "DAPI - Hoechst (nuclei)",
                "FITC - Laminin (basement membrane)",
                "Cy3 - Synaptopodin (glomerular)",
                "Cy5 - THP (thick limb)"
              ]
            },
            {
              "field": "y",
              "type": "quantitative",
              "values": null
            },
            {
              "field": "x",
              "type": "quantitative",
              "values": null
            }
          ],
          "isPyramid": true,
          "transform": {
            "translate": {
              "y": 0,
              "x": 0
            },
            "scale": 1
          }
        }
      }
    ]
  }
}
`}
js={`
const options = {
  "schemaVersion": "0.0.2",
  "images": [
    {
      "name": "My Bioformats-Zarr Image",
      "url": "http://example.com/my_image.zarr",
      "type": "zarr",
      "metadata": {
        "dimensions": [
          {
            "field": "channel",
            "type": "nominal",
            "values": [
              "DAPI - Hoechst (nuclei)",
              "FITC - Laminin (basement membrane)",
              "Cy3 - Synaptopodin (glomerular)",
              "Cy5 - THP (thick limb)"
            ]
          },
          {
            "field": "y",
            "type": "quantitative",
            "values": null
          },
          {
            "field": "x",
            "type": "quantitative",
            "values": null
          }
        ],
        "isPyramid": true,
        "transform": {
          "translate": {
            "y": 0,
            "x": 0
          },
          "scale": 1
        }
      }
    }
  ]
};
const dataset = vc
  .addDataset("My dataset")
  .addFile(
    undefined,
    dt.RASTER,
    ft.RASTER_JSON,
    options
  );
`}
  />


### `raster.ome-zarr`

Vitessce supports [OME-NGFF](https://ngff.openmicroscopy.org/latest/) images saved as Zarr stores and a subset of OME-NGFF features via the `raster.ome-zarr` file type.
The following table lists the support for different OME-NGFF features:

| Feature | Supported by Vitessce |
|-----|-----|
| Downsampling along Z axis | N |
| `omero` field | Y |
| multiscales with a scaling factor other than 2 | N |
| URL (not only S3) | Y |
| `multiscales[].axes` (added in v0.3) | Y |
| 3D view | Y |
| labels | N |
| HCS plate | N |

To compare Vitessce to other OME-NGFF clients, see the [table](https://github.com/ome/ngff/issues/71) listing the OME-NGFF features supported by other clients.
We welcome feature requests or pull requests to add support for the remaining features to Vitessce.

- View config file definition snippet:

  <ViewConfigTabs
json={`
{
  "url": "http://example.com/my_image.ome.zarr",
  "type": "raster",
  "fileType": "raster.ome-zarr"
}
`}
js={`
const dataset = vc
  .addDataset("My dataset")
  .addFile(
    "url": "http://example.com/my_image.ome.zarr",
    dt.RASTER,
    ft.RASTER_OME_ZARR
  );
`}
  />


### `neighborhoods.json`

- [JSON schema](https://github.com/vitessce/vitessce/blob/main/src/schemas/neighborhoods.schema.json)
- [JSON schema fixture](https://github.com/vitessce/vitessce/blob/main/src/schemas/fixtures/neighborhoods.good.json)
- [Example file](https://s3.amazonaws.com/vitessce-data/0.0.31/master_release/linnarsson/linnarsson.neighborhoods.json)
- View config file definition snippet:

  <ViewConfigTabs
json={`
{
  "url": "http://example.com/my_neighborhoods.json",
  "type": "neighborhoods",
  "fileType": "neighborhoods.json"
}
`}
js={`
const dataset = vc
  .addDataset("My dataset")
  .addFile(
    "http://example.com/my_neighborhoods.json",
    dt.NEIGHBORHOODS,
    ft.NEIGHBORHOODS_JSON
  );
`}
  />

### `genomic-profiles.zarr`

- View config file definition snippet:

  <ViewConfigTabs
json={`
{
  "url": "http://example.com/my_genomic_profiles.zarr",
  "type": "genomic-profiles",
  "fileType": "genomic-profiles.zarr"
}
`}
js={`
const dataset = vc
  .addDataset("My dataset")
  .addFile(
    "url": "http://example.com/my_genomic_profiles.zarr",
    dt.GENOMIC_PROFILES,
    ft.GENOMIC_PROFILES_ZARR
  );
`}
  />


## Other File Formats

Other file formats must be converted to one or more of the file types listed above prior to being used with Vitessce.
Here we provide tips for conversion from common single-cell file formats.

### AnnData as h5ad

#### Convert to Zarr

Use AnnData's [`read_h5ad`](https://anndata.readthedocs.io/en/latest/anndata.read_loom.html) function to load the file as an AnnData object, then use the [`.write_zarr`](https://anndata.readthedocs.io/en/latest/anndata.AnnData.write_zarr.html) function to convert to a Zarr store. 

```python
from anndata import read_h5ad
import zarr

adata = read_h5ad('path/to/my_dataset.h5ad')
adata.write_zarr('my_store.zarr')
```

Converted outputs can be used with the [AnnData as Zarr](#anndata-as-zarr) family of native file types.

:::note
The ids in the `obs` part of the `AnnData` store must match the other data files with which you wish to coordinate outside the `AnnData` store.  For example, if you have a bitmask that you wish to use with an `AnnData` store, the ids in `obs` need to be the very integers from each segmentation the bitmask.
:::

#### Use or Store a subset of X

When the full expression matrix `adata.X` is large, there may be performance costs if Vitessce tries to load the full matrix for visualization, whether it be a heatmap
or just loading genes to overlay on a spatial or scatterplot view.
To offset this there are two things you can do:
1. Use CSC format or chunk the zarr store efficiently (the later is recommended at the moment, see below) so that the UI remains responsive when selecting a gene to load into the client.
Every time a gene is selected (or the heatmap is loaded), the client will use Zarr to fetch all the "cell x gene" information needed for rendering - however, a poor chunking strategy
can result in too much data be loaded (and then not used).  To remedy this, we recommend passing in the `chunk_size` argument to `write_zarr` so that the data is chunked in a manner that allows
remote sources (like browsers) to fetch only the genes (and all cells) necessary for efficient display - to this end the chunk size is usually something like `[num_cells, small_number]`
so every chunk contains all the cells, but only a few genes.  That way, when you select a gene, only a small chunk of data is fetched for rendering and little is wasted.  Ideally, at most
one small request is made for every selection.  You are welcome to try different chunking strategies as you see fit though!
2. If only interested in a subset of the expression matrix for a heatmap, a filter (`matrixGeneFilter` in the view config) for the matrix can be stored as a boolean array in `var`.
In this case, it is the `highly_variable` key from the `sc.pp.highly_variable_genes` call below.  This will not alter the genes displayed in the `Genes` view (use `geneFilter` for that in the view config).

```python
import scanpy as sc
from anndata import read_h5ad
import zarr

adata = read_h5ad('path/to/my_dataset.h5ad')

# Adds the `highly_variable` key to `var`
sc.pp.highly_variable_genes(adata, n_top_genes=200)
# If the matrix is sparse, it's best for performance to
# use non-sparse formats + chunking to keep the UI responsive.
# In the future, we should be able to use CSC sparse data natively
# and get equal performance with chunking:
# https://github.com/theislab/anndata/issues/524 
# but for now, it is still not as good (although not unusable).
if isinstance(adata.X, sparse.spmatrix):
    adata.X = adata.X.todense() # Or adata.X.tocsc() if you need to.
adata.write_zarr(zarr_path, [adata.shape[0], VAR_CHUNK_SIZE])  # VAR_CHUNK_SIZE should be something small like 10
```

Alternatively, a smaller matrix can be stored as multi-dimensional observation array in `adata.obsm` and used in conjunction with the `geneFilter` part of the view config.

```python
sc.pp.highly_variable_genes(adata, n_top_genes=200)
adata.obsm['X_top_200_genes'] = adata[:, adata.var['highly_variable']].X.copy()
adata.write_zarr('my_store.zarr')
```

Converted outputs can be used with the [AnnData as Zarr](#anndata-as-zarr) family of native file types. Both dense and sparse expression matrices are supported.

### Loom

#### Convert to Zarr via AnnData

Use AnnData's [`read_loom`](https://anndata.readthedocs.io/en/latest/anndata.read_loom.html) function to load the Loom file as an AnnData object, then use the [`.write_zarr`](https://anndata.readthedocs.io/en/latest/anndata.AnnData.write_zarr.html) function to convert to a Zarr store. 

```python
from anndata import read_loom

adata = read_loom(
  'path/to/my_dataset.loom',
  obsm_names={ "tSNE": ["_tSNE_1", "_tSNE_2"], "spatial": ["X", "Y"] }
)
adata.write_zarr('my_store.zarr')
```

Converted outputs can be used with the [AnnData as Zarr](#anndata-as-zarr) family of native file types.

### Seurat

The Vitessce R package can be used to [convert Seurat objects](https://vitessce.github.io/vitessceR/reference/SeuratWrapper.html) to the [`cells.json`](#cellsjson) and [`cell-sets.json`](#cell-setsjson) file types.

### SnapATAC

The Vitessce Python package can be used to [convert SnapATAC outputs](https://vitessce.github.io/vitessce-python/data_examples.html) to the [`genomic-profiles.zarr`](#genomic-profileszarr), [`cells.json`](#cellsjson), and [`cell-sets.json`](#cell-setsjson) file types.

### Proprietary Image Formats

The [Bio-Formats](https://www.glencoesoftware.com/blog/2019/12/09/converting-whole-slide-images-to-OME-TIFF.html) suite of tools can be used to convert from proprietary image formats to one of the open standard [OME file formats](http://www.openmicroscopy.org/ome-files/) supported by Vitessce.

:::tip
The [Data Preparation](http://viv.gehlenborglab.org/#data-preparation) section of the Viv documentation is a helpful resource for learning about converting to OME formats.
:::

#### Conversion to OME-TIFF

[OME-TIFF](https://docs.openmicroscopy.org/ome-model/6.0.0/index.html#ome-tiff) images are supported via the [`raster.json`](#rasterjson) file type.

#### Conversion to OME-NGFF

[OME-NGFF](https://ngff.openmicroscopy.org/latest/) images saved as Zarr stores are supported via the [`raster.ome-zarr`](#rasterome-zarr) file type.

:::tip
The [`ome-zarr`](https://pypi.org/project/ome-zarr/) Python package can be used to read the metadata of  `OME-Zarr` images.
:::