/* eslint-disable camelcase */
import React, { useEffect, useMemo } from 'react';
import {
  ThemeProvider,
  StylesProvider,
  createGenerateClassName,
} from '@material-ui/core/styles';
import isEqual from 'lodash/isEqual';
import { META_VERSION } from '@vitessce/constants-internal';
import { buildConfigSchema, latestConfigSchema } from '@vitessce/schemas';
import { muiTheme } from './shared-mui/styles';
import {
  ViewConfigProvider,
  createViewConfigStore,
  AuxiliaryProvider,
  createAuxiliaryStore,
} from './state/hooks';

import VitessceGrid from './VitessceGrid';
import { Warning } from './Warning';
import CallbackPublisher from './CallbackPublisher';
import {
  initialize,
} from './view-config-utils';
import { fromEntries } from '@vitessce/utils';

function logConfig(config, name) {
  console.groupCollapsed(`ðŸš„ Vitessce (${META_VERSION.version}) ${name}`);
  console.info(`data:,${JSON.stringify(config)}`);
  console.info(JSON.stringify(config, null, 2));
  console.groupEnd();
}

/**
 * The Vitessce component.
 * @param {object} props
 * @param {object} props.config A Vitessce view config.
 * If the config is valid, the VitessceGrid will be rendered as a child.
 * If the config is invalid, a Warning will be rendered instead.
 * @param {number} props.rowHeight Row height for grid layout. Optional.
 * @param {number} props.height Total height for grid layout. Optional.
 * @param {string} props.theme The theme, used for styling as
 * light or dark. Optional. By default, "dark"
 * @param {function} props.onWarn A callback for warning messages. Optional.
 * @param {function} props.onConfigChange A callback for view config
 * updates. Optional.
 * @param {function} props.onLoaderChange A callback for loader
 * updates. Optional.
 * @param {boolean} props.validateOnConfigChange Whether to validate
 * against the view config schema when publishing changes. Use for debugging
 * purposes, as this may have a performance impact. By default, false.
 * @param {undefined|string} props.uid A unique identifier for this Vitessce instance,
 * for the purpose of avoiding CSS autogenerated class name conflicts. Must be valid as part
 * of a CSS class name string.
 */
export function VitS(props) {
  const {
    config,
    rowHeight,
    height,
    theme,
    onWarn,
    onConfigChange,
    onLoaderChange,
    validateOnConfigChange = false,
    isBounded = false,
    uid,
    viewTypes,
    fileTypes,
    jointFileTypes,
    coordinationTypes,
    warning,
  } = props;

  const generateClassName = useMemo(() => createGenerateClassName({
    disableGlobal: false, // Class names need to be deterministic
    // Avoid conflicts with portal-ui MUI class names,
    // and allow setting a UID.
    productionPrefix: (uid ? `vit${uid}` : 'vit'),
  }), [uid]);

  // TODO: change to config?.uid when that field is added
  const configUid = config?.name;
  const configVersion = config?.version;

  const pluginSpecificConfigSchema = useMemo(() => buildConfigSchema(
    fromEntries([
      ...fileTypes.map(ft => ([ft.name, ft.optionsSchema])),
      ...jointFileTypes.map(ft => ([ft.name, ft.optionsSchema])),
    ]),
    // TODO: refactor buildConfigSchema to do these fromEntries and .optional() internally
    fromEntries(coordinationTypes.map(ct => ([ct.name, ct.valueSchema.optional()]))),
    viewTypes.map(vt => vt.name),
  ), [viewTypes, fileTypes, jointFileTypes, coordinationTypes]);

  // Process the view config and memoize the result:
  // - Validate.
  // - Upgrade, if legacy schema.
  // - Validate after upgrade, if legacy schema.
  // - Initialize (based on initStrategy).
  const [configOrWarning, success] = useMemo(() => {
    if (warning) {
      return [warning, false];
    }
    logConfig(config, 'input view config');
    const result = latestConfigSchema.safeParse(config);
    if (result.success) {
      const upgradedConfig = result.data;
      logConfig(upgradedConfig, 'upgraded view config');
      // Perform second round of parsing against plugin-specific config schema.
      const pluginSpecificResult = pluginSpecificConfigSchema.safeParse(upgradedConfig);
      // Initialize the view config according to the initStrategy.
      if (pluginSpecificResult.success) {
        try {
          const upgradedConfigWithValidPlugins = pluginSpecificResult.data;
          const initializedConfig = initialize(
            upgradedConfigWithValidPlugins,
            jointFileTypes,
            coordinationTypes,
            viewTypes,
          );
          logConfig(initializedConfig, 'initialized view config');
          return [initializedConfig, true];
        } catch (e) {
          return [
            {
              title: 'View config initialization failed.',
              unformatted: e.message,
            },
            false,
          ];
        }
      }
      return [
        {
          title: 'View config checks failed.',
          unformatted: pluginSpecificResult.error.message,
        },
        false,
      ];
    }
    return [{
      title: 'View config validation failed.',
      unformatted: result.error.message,
    }, result.success];
  }, [configUid, configVersion, pluginSpecificConfigSchema, warning]);

  // Emit the upgraded/initialized view config
  // to onConfigChange if necessary.
  useEffect(() => {
    if (success && !isEqual(configOrWarning, config) && onConfigChange) {
      onConfigChange(configOrWarning);
    }
  }, [success, configUid, configOrWarning, onConfigChange]);

  return success ? (
    <StylesProvider generateClassName={generateClassName}>
      <ThemeProvider theme={muiTheme[theme]}>
        <ViewConfigProvider createStore={createViewConfigStore}>
          <AuxiliaryProvider createStore={createAuxiliaryStore}>
            <VitessceGrid
              viewTypes={viewTypes}
              fileTypes={fileTypes}
              coordinationTypes={coordinationTypes}
              config={configOrWarning}
              rowHeight={rowHeight}
              height={height}
              theme={theme}
              isBounded={isBounded}
            />
            <CallbackPublisher
              onWarn={onWarn}
              onConfigChange={onConfigChange}
              onLoaderChange={onLoaderChange}
              validateOnConfigChange={validateOnConfigChange}
              pluginSpecificConfigSchema={pluginSpecificConfigSchema}
            />
          </AuxiliaryProvider>
        </ViewConfigProvider>
      </ThemeProvider>
    </StylesProvider>
  ) : (
    <StylesProvider generateClassName={generateClassName}>
      <ThemeProvider theme={muiTheme[theme]}>
        <Warning {...configOrWarning} />
      </ThemeProvider>
    </StylesProvider>
  );
}
